<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connect Four: Slide!</title>
    <style>
        /* Base styling */
        
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 30px;
            background: linear-gradient(135deg, #f0f8ff, #e6e6fa);
            min-height: 100vh;
        }
        
        h2 {
            margin-bottom: 10px;
        }
        /* Layout container for clocks and game board */
        
        #game-layout {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            max-width: 900px;
            margin-bottom: 10px;
        }
        /* Left and right clock containers */
        
        .clockBox {
            width: 120px;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0 20px;
        }
        
        .clock-label {
            font-weight: bold;
            margin-bottom: 5px;
        }
        
        .clock-time {
            background: #222;
            color: #0f0;
            padding: 5px 10px;
            font-family: monospace;
            font-size: 1.2em;
            border-radius: 5px;
            text-align: center;
            min-width: 90px;
        }
        /* Game board container */
        
        #game-board {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        /* Column drop button bar */
        
        #columnButtons {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 4px;
            margin-bottom: 10px;
        }
        /* The game container holding the board & row insertion buttons */
        
        #game {
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        /* The board, styled as a grid */
        
        #board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
            background-color: #1a1a1a;
            padding: 6px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #aaa 20%, #444);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease-in;
        }
        
        .player1 {
            background: red;
        }
        
        .player2 {
            background: blue;
        }
        
        button {
            margin: 2px;
            padding: 4px 8px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        /* Row insertion controls */
        
        .row-controls {
            display: grid;
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
            margin: 0;
        }
        
        .row-controls button {
            width: 50px;
            height: 50px;
            margin: 0;
        }
        
        .arrow {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player1-btn {
            background-color: red;
            color: white;
        }
        
        .player2-btn {
            background-color: blue;
            color: white;
        }
        
        #status {
            margin: 10px;
            font-size: 1.2em;
        }
        /* AI and Timer settings */
        
        #ai-settings,
        #timer-settings {
            width: 400px;
            margin: 10px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
        }
        /* Range slider styled as a number line with tick marks.
       We use a repeating-linear-gradient so that ticks appear at evenly spaced intervals.
       With 1–7 values, there are 6 intervals, so we set background-size to calc(100%/6). */
        
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            background-image: repeating-linear-gradient( to right, #666, #666 1px, transparent 1px, transparent calc(100%/6));
            outline: none;
            margin: 10px 0;
        }
        
        input[type=range]:focus {
            outline: none;
        }
        
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #666;
            cursor: pointer;
            margin-top: -5px;
        }
        /* Timer fields: increase width to 4ch and restrict values */
        
        input[type=number]#timer-p1-min,
        input[type=number]#timer-p1-sec,
        input[type=number]#timer-p2-min,
        input[type=number]#timer-p2-sec {
            width: 4ch;
            text-align: right;
        }
        
        #rules {
            max-width: 700px;
            text-align: center;
            margin: 20px;
            font-size: 1em;
            line-height: 1.5em;
        }
    </style>
</head>

<body>
    <h2>Connect Four: Slide!</h2>
    <!-- Game Layout: Clocks and Game Board -->
    <div id="game-layout">
        <div id="clockLeft" class="clockBox">
            <div class="clock-label" id="clockLabelLeft"></div>
            <div class="clock-time" id="clockTimeLeft"></div>
        </div>
        <div id="game-board">
            <div id="columnButtons" class="controls"></div>
            <div id="game">
                <div id="rowButtonsLeft" class="row-controls"></div>
                <div id="board"></div>
                <div id="rowButtonsRight" class="row-controls"></div>
            </div>
        </div>
        <div id="clockRight" class="clockBox">
            <div class="clock-label" id="clockLabelRight"></div>
            <div class="clock-time" id="clockTimeRight"></div>
        </div>
    </div>
    <!-- Status and New Game Button -->
    <p id="status"></p>
    <button onclick="startNewGame()">New Game</button>
    <!-- AI Settings -->
    <div id="ai-settings">
        <label>
      <input type="checkbox" id="ai-toggle"> Play vs AI
    </label>
        <br/>
        <label>
      AI Difficulty:
      <!-- Slider from 1 to 7 with tick marks -->
      <input type="range" id="ai-difficulty" min="1" max="7" step="1" value="3">
      <span id="ai-difficulty-value">3</span>
    </label>
        <br/>
        <label>
      Human plays as:
      <select id="human-player">
        <option value="1">Player 1</option>
        <option value="2">Player 2</option>
      </select>
    </label>
    </div>
    <!-- Timer Settings -->
    <div id="timer-settings">
        <label>
      <input type="checkbox" id="timer-toggle"> Enable Timer
    </label>
        <br/>
        <label>
      Player 1 Time:
      <input type="number" id="timer-p1-min" value="5" min="0" max="99"> min 
      <input type="number" id="timer-p1-sec" value="0" min="0" max="59"> sec
    </label>
        <br/>
        <label>
      Player 2 Time:
      <input type="number" id="timer-p2-min" value="5" min="0" max="99"> min 
      <input type="number" id="timer-p2-sec" value="0" min="0" max="59"> sec
    </label>
    </div>
    <div id="rules">
        <p><strong>My personal version of Connect Four. Rules are:</strong></p>
        <p>Four disks lined up in any direction wins. However, in addition to dropping in columns, disks can be inserted from either side of any row.</p>
        <p>Gravity is in effect – if a disk is pushed over with nothing beneath it, it will fall.</p>
        <p>Empty spaces fill by sliding rows; if a row is full, a new disk pushes the opposite end off the board.</p>
        <p>A win may result from any move (drop or slide), so pay attention to shifting board states.</p>
        <p>If your move causes a connected four for your opponent (a trap), your opponent wins. This is true even if your move creates your own connected four.</p>
        <p>Repeating the same board state three times results in a draw.</p>
    </div>

    <script>
        ////////////////////// Global Variables and Settings //////////////////////
        const rows = 6,
            cols = 7;
        let board;
        let currentPlayer;
        let winLineSvg = null;
        // AI settings
        let isAIEnabled = false;
        let aiDifficulty = 3; // Levels 1–7
        let humanPlayer = 1,
            aiPlayer = 2;
        // Timer variables
        let timerEnabled = false;
        let timerP1 = 0,
            timerP2 = 0;
        let timerInterval = null;
        let gameOver = false;
        // Move history (for stalemate/repetition checking)
        let moveHistory = [];
        // Transposition table for caching minimax evaluations.
        let transpositionTable = {};

        // DOM Elements
        const boardDiv = document.getElementById('board');
        const status = document.getElementById('status');
        const colDiv = document.getElementById('columnButtons');
        const rowLeftDiv = document.getElementById('rowButtonsLeft');
        const rowRightDiv = document.getElementById('rowButtonsRight');
        const clockLabelLeft = document.getElementById('clockLabelLeft');
        const clockTimeLeft = document.getElementById('clockTimeLeft');
        const clockLabelRight = document.getElementById('clockLabelRight');
        const clockTimeRight = document.getElementById('clockTimeRight');

        // AI and Timer Settings listeners
        document.getElementById('ai-toggle').addEventListener('change', function() {
            isAIEnabled = this.checked;
        });
        document.getElementById('ai-difficulty').addEventListener('input', function() {
            aiDifficulty = parseInt(this.value);
            document.getElementById('ai-difficulty-value').textContent = this.value;
        });
        document.getElementById('human-player').addEventListener('change', function() {
            humanPlayer = parseInt(this.value);
            aiPlayer = 3 - humanPlayer;
        });
        document.getElementById('timer-toggle').addEventListener('change', function() {
            timerEnabled = this.checked;
        });

        ////////////////////// HELPER FUNCTIONS //////////////////////
        // Serialize a board state (accepting a specific board array)
        function serializeBoard(boardArg) {
            return boardArg.map(row => row.join(',')).join(';');
        }

        // Order moves by quickly evaluating the board after each move.
        function orderMoves(legalMoves, simBoard, isMaximizing, player) {
            // Create an array of moves with their quick score
            let movesWithScore = legalMoves.map(move => {
                let copy = cloneBoard(simBoard);
                simulateMoveOnBoard(copy, move, player);
                let score = evaluateBoard(copy);
                return {
                    move,
                    score
                };
            });
            // Sort descending if maximizing, ascending if minimizing.
            movesWithScore.sort((a, b) => isMaximizing ? (b.score - a.score) : (a.score - b.score));
            return movesWithScore.map(ms => ms.move);
        }

        ////////////////////// GAME INITIALIZATION //////////////////////
        function startNewGame() {
            board = Array.from({
                length: rows
            }, () => Array(cols).fill(null));
            humanPlayer = parseInt(document.getElementById('human-player').value);
            aiPlayer = 3 - humanPlayer;
            currentPlayer = 1;
            if (winLineSvg) {
                winLineSvg.remove();
                winLineSvg = null;
            }
            // Clear transposition cache for each new decision/game.
            transpositionTable = {};
            moveHistory = [];
            gameOver = false;
            if (document.getElementById('timer-toggle').checked) {
                timerEnabled = true;
                timerP1 = parseInt(document.getElementById('timer-p1-min').value) * 60 +
                    parseInt(document.getElementById('timer-p1-sec').value);
                timerP2 = parseInt(document.getElementById('timer-p2-min').value) * 60 +
                    parseInt(document.getElementById('timer-p2-sec').value);
                startTimer();
            } else {
                timerEnabled = false;
                clearInterval(timerInterval);
            }
            setupButtons();
            update();
            status.textContent = `Player ${currentPlayer}'s turn`;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = false;
            });
            if (isAIEnabled && currentPlayer === aiPlayer) {
                disableButtons();
                aiMakeMove();
            }
        }

        function startTimer() {
            clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 1000);
        }

        function updateTimer() {
            if (gameOver) {
                clearInterval(timerInterval);
                return;
            }
            if (currentPlayer === 1) {
                timerP1--;
                if (timerP1 <= 0) {
                    timerP1 = 0;
                    status.textContent = "Time’s up for " + (humanPlayer === 1 ? "Player 1" : "AI") +
                        " – " + (humanPlayer === 1 ? "Player 2 wins by timeout!" : "Player 1 wins by timeout!");
                    disableButtons();
                    gameOver = true;
                    clearInterval(timerInterval);
                }
            } else {
                timerP2--;
                if (timerP2 <= 0) {
                    timerP2 = 0;
                    status.textContent = "Time’s up for " + (humanPlayer === 2 ? "Player 2" : "AI") +
                        " – " + (humanPlayer === 2 ? "Player 1 wins by timeout!" : "Player 2 wins by timeout!");
                    disableButtons();
                    gameOver = true;
                    clearInterval(timerInterval);
                }
            }
            updateClockDisplay();
        }

        function updateClockDisplay() {
            if (!isAIEnabled) {
                clockLabelLeft.textContent = "Player 1:";
                clockLabelRight.textContent = "Player 2:";
            } else {
                clockLabelLeft.textContent = (humanPlayer === 1) ? "Player 1:" : "AI:";
                clockLabelRight.textContent = (humanPlayer === 2) ? "Player 2:" : "AI:";
            }

            clockTimeLeft.textContent = formatTime(timerP1);
            clockTimeRight.textContent = formatTime(timerP2);
        }



        function formatTime(seconds) {
            let m = Math.floor(seconds / 60);
            let s = seconds % 60;
            return `${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }

        ////////////////////// BOARD RENDERING AND GRAVITY //////////////////////
        function createBoard() {
            boardDiv.innerHTML = '';
            if (winLineSvg) {
                boardDiv.appendChild(winLineSvg);
            }
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[r][c]) {
                        cell.classList.add(`player${board[r][c]}`);
                    }
                    boardDiv.appendChild(cell);
                }
            }
        }

        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (board[r][c]) {
                        stack.push(board[r][c]);
                    }
                }
                for (let r = rows - 1; r >= 0; r--) {
                    board[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        ////////////////////// MOVE FUNCTIONS //////////////////////
        function dropInColumn(col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = currentPlayer;
                    applyGravity();
                    checkAndSwitchTurn();
                    return;
                }
            }
            console.log("Column is full!");
        }

        function insertInRowLeft(row) {
            if (board[row][0] === null) {
                board[row][0] = currentPlayer;
            } else {
                let end = 0;
                while (end < cols && board[row][end] !== null) {
                    end++;
                }
                if (end < cols) {
                    for (let i = end; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                } else {
                    for (let i = cols - 1; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                }
                board[row][0] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        function insertInRowRight(row) {
            if (board[row][cols - 1] === null) {
                board[row][cols - 1] = currentPlayer;
            } else {
                let start = cols - 1;
                while (start >= 0 && board[row][start] !== null) {
                    start--;
                }
                if (start >= 0) {
                    for (let i = start + 1; i < cols; i++) {
                        board[row][i - 1] = board[row][i];
                    }
                } else {
                    for (let i = 0; i < cols - 1; i++) {
                        board[row][i] = board[row][i + 1];
                    }
                }
                board[row][cols - 1] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        ////////////////////// WIN CHECKING & OVERLAY //////////////////////
        function checkForWinForPlayer(player) {
            // Horizontal check
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r][c + 1] === player &&
                        board[r][c + 2] === player &&
                        board[r][c + 3] === player
                    )
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r, c + 1],
                                [r, c + 2],
                                [r, c + 3]
                            ]
                        };
                }
            }
            // Vertical check
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c] === player &&
                        board[r + 2][c] === player &&
                        board[r + 3][c] === player
                    )
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c],
                                [r + 2, c],
                                [r + 3, c]
                            ]
                        };
                }
            }
            // Diagonal down-right check
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c + 1] === player &&
                        board[r + 2][c + 2] === player &&
                        board[r + 3][c + 3] === player
                    )
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c + 1],
                                [r + 2, c + 2],
                                [r + 3, c + 3]
                            ]
                        };
                }
            }
            // Diagonal down-left check
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c - 1] === player &&
                        board[r + 2][c - 2] === player &&
                        board[r + 3][c - 3] === player
                    )
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c - 1],
                                [r + 2, c - 2],
                                [r + 3, c - 3]
                            ]
                        };
                }
            }
            return null;
        }

        function displayWinLine(cells) {
            const firstCell = cells[0],
                lastCell = cells[cells.length - 1],
                x1 = 31 + firstCell[1] * 54,
                y1 = 31 + firstCell[0] * 54,
                x2 = 31 + lastCell[1] * 54,
                y2 = 31 + lastCell[0] * 54;
            const svgNS = "http://www.w3.org/2000/svg";
            winLineSvg = document.createElementNS(svgNS, "svg");
            winLineSvg.setAttribute("width", boardDiv.clientWidth);
            winLineSvg.setAttribute("height", boardDiv.clientHeight);
            winLineSvg.style.position = "absolute";
            winLineSvg.style.top = "0";
            winLineSvg.style.left = "0";
            const lineBorder = document.createElementNS(svgNS, "line");
            lineBorder.setAttribute("x1", x1);
            lineBorder.setAttribute("y1", y1);
            lineBorder.setAttribute("x2", x2);
            lineBorder.setAttribute("y2", y2);
            lineBorder.setAttribute("stroke", "black");
            lineBorder.setAttribute("stroke-width", "16");
            lineBorder.setAttribute("stroke-linecap", "round");
            const lineWhite = document.createElementNS(svgNS, "line");
            lineWhite.setAttribute("x1", x1);
            lineWhite.setAttribute("y1", y1);
            lineWhite.setAttribute("x2", x2);
            lineWhite.setAttribute("y2", y2);
            lineWhite.setAttribute("stroke", "white");
            lineWhite.setAttribute("stroke-width", "8");
            lineWhite.setAttribute("stroke-linecap", "round");
            winLineSvg.appendChild(lineBorder);
            winLineSvg.appendChild(lineWhite);
            boardDiv.appendChild(winLineSvg);
        }

        ////////////////////// REPETITION (STALEMATE) CHECK //////////////////////
        function serializeBoard(boardArg) {
            return boardArg.map(row => row.join(',')).join(';');
        }

        function updateHistory() {
            moveHistory.push(serializeBoard(board));
        }

        function checkForRepetition() {
            const current = serializeBoard(board);
            let count = 0;
            for (let state of moveHistory) {
                if (state === current) count++;
            }
            return count >= 3;
        }

        ////////////////////// TURN MANAGEMENT //////////////////////
        function checkAndSwitchTurn() {
            const winCurrent = checkForWinForPlayer(currentPlayer);
            const winOpponent = checkForWinForPlayer(3 - currentPlayer);
            if (winCurrent || winOpponent) {
                update();
                setTimeout(() => {
                    if (winOpponent) {
                        displayWinLine(winOpponent.cells);
                        status.textContent = `Player ${3 - currentPlayer} wins by trap!`;
                        disableButtons();
                        gameOver = true;
                        clearInterval(timerInterval);
                    } else if (winCurrent) {
                        displayWinLine(winCurrent.cells);
                        status.textContent = `Player ${currentPlayer} wins!`;
                        disableButtons();
                        gameOver = true;
                        clearInterval(timerInterval);
                    }
                }, 200);
                return;
            }
            updateHistory();
            if (checkForRepetition()) {
                status.textContent = "Game drawn by repetition (stalemate)!";
                disableButtons();
                gameOver = true;
                clearInterval(timerInterval);
                return;
            }
            currentPlayer = 3 - currentPlayer;
            setupButtons();
            update();
            if (timerEnabled) {
                if ((currentPlayer === 1 && timerP1 <= 0) || (currentPlayer === 2 && timerP2 <= 0)) {
                    status.textContent = `Player ${currentPlayer} loses by timeout!`;
                    disableButtons();
                    gameOver = true;
                    clearInterval(timerInterval);
                    return;
                }
            }
            if (isAIEnabled && currentPlayer === aiPlayer) {
                disableButtons();
                aiMakeMove();
            }
        }

        function update() {
            createBoard();
            const btnClass = `player${currentPlayer}-btn`;
            document.querySelectorAll('.arrow').forEach(btn => {
                btn.className = `arrow ${btnClass}`;
            });
            if (!status.textContent.includes("wins") && !status.textContent.includes("drawn"))
                status.textContent = `Player ${currentPlayer}'s turn`;
            if (isAIEnabled && currentPlayer !== humanPlayer)
                document.querySelectorAll('.arrow').forEach(btn => btn.disabled = true);
            else
                document.querySelectorAll('.arrow').forEach(btn => btn.disabled = false);
            if (timerEnabled) updateClockDisplay();
        }

        function disableButtons() {
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = true;
            });
        }

        function setupButtons() {
            colDiv.innerHTML = '';
            rowLeftDiv.innerHTML = '';
            rowRightDiv.innerHTML = '';
            for (let c = 0; c < cols; c++) {
                const btn = document.createElement('button');
                btn.innerHTML = '↓';
                btn.className = `arrow player${currentPlayer}-btn`;
                btn.onclick = () => dropInColumn(c);
                colDiv.appendChild(btn);
            }
            for (let r = 0; r < rows; r++) {
                const leftBtn = document.createElement('button');
                leftBtn.innerHTML = '→';
                leftBtn.className = `arrow player${currentPlayer}-btn`;
                leftBtn.onclick = () => insertInRowLeft(r);
                rowLeftDiv.appendChild(leftBtn);
                const rightBtn = document.createElement('button');
                rightBtn.innerHTML = '←';
                rightBtn.className = `arrow player${currentPlayer}-btn`;
                rightBtn.onclick = () => insertInRowRight(r);
                rowRightDiv.appendChild(rightBtn);
            }
        }

        ////////////////////// AI OPPONENT CODE //////////////////////
        function aiMakeMove() {
            // Clear the transposition table at the start of each AI decision.
            transpositionTable = {};
            setTimeout(() => {
                const move = chooseAIMove();
                if (move.type === 'drop') dropInColumn(move.index);
                else if (move.type === 'insertLeft') insertInRowLeft(move.index);
                else if (move.type === 'insertRight') insertInRowRight(move.index);
            }, 500);
        }

        function getLegalMoves(simBoard) {
            let moves = [];
            for (let c = 0; c < cols; c++) {
                if (simBoard[0][c] === null) moves.push({
                    type: 'drop',
                    index: c
                });
            }
            for (let r = 0; r < rows; r++) {
                moves.push({
                    type: 'insertLeft',
                    index: r
                });
                moves.push({
                    type: 'insertRight',
                    index: r
                });
            }
            return moves;
        }

        // chooseAIMove uses our original logic for levels 1-3 and then minimax for 4-7.
        function chooseAIMove() {
            let legalMoves = getLegalMoves(board);
            // Check for immediate win for AI first.
            for (let move of legalMoves)
                if (simulateAndCheckWin(move, aiPlayer)) return move;

            if (aiDifficulty === 1) {
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 2) {
                // Level 2: Consider only drop moves from human.
                let oppLegalMoves = [];
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === null) oppLegalMoves.push({
                        type: 'drop',
                        index: c
                    });
                }
                let opponentWinningMoves = [];
                for (let oppMove of oppLegalMoves)
                    if (simulateAndCheckWin(oppMove, humanPlayer)) opponentWinningMoves.push(oppMove);
                let candidateMoves = [];
                for (let candidate of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, candidate, aiPlayer);
                    let blocks = true;
                    for (let oppMove of opponentWinningMoves) {
                        let sim2 = cloneBoard(sim);
                        simulateMoveOnBoard(sim2, oppMove, humanPlayer);
                        if (checkForWinForPlayerOnBoard(sim2, humanPlayer)) {
                            blocks = false;
                            break;
                        }
                    }
                    if (blocks) candidateMoves.push(candidate);
                }
                if (candidateMoves.length > 0)
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 3) {
                // Level 3: Consider both drop and insertion moves from human.
                let opponentLegalMoves = getLegalMoves(board);
                let opponentWinningMoves = [];
                for (let oppMove of opponentLegalMoves)
                    if (simulateAndCheckWin(oppMove, humanPlayer)) opponentWinningMoves.push(oppMove);
                let candidateMoves = [];
                for (let candidate of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, candidate, aiPlayer);
                    let blocks = true;
                    for (let oppMove of opponentWinningMoves) {
                        let sim2 = cloneBoard(sim);
                        simulateMoveOnBoard(sim2, oppMove, humanPlayer);
                        if (checkForWinForPlayerOnBoard(sim2, humanPlayer)) {
                            blocks = false;
                            break;
                        }
                    }
                    if (blocks) candidateMoves.push(candidate);
                }
                if (candidateMoves.length > 0)
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty >= 4 && aiDifficulty <= 7) {
                // Levels 4-7 use deeper search via minimax with alpha-beta pruning.
                // Choose depth based on difficulty level.
                let depth;
                switch (aiDifficulty) {
                    case 4:
                        depth = 2;
                        break;
                    case 5:
                        depth = 3;
                        break;
                    case 6:
                        depth = 4;
                        break;
                    case 7:
                        depth = 5;
                        break;
                }
                let bestScore = -Infinity;
                let bestMoves = [];
                // Order moves first to improve pruning and search efficiency.
                let orderedMoves = orderMoves(legalMoves, board, true, aiPlayer);
                for (let move of orderedMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, move, aiPlayer);
                    let score = minimaxAlphaBeta(sim, depth, false, -Infinity, Infinity);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                if (bestMoves.length > 0)
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        }

        function simulateAndCheckWin(move, player) {
            const simBoard = cloneBoard(board);
            simulateMoveOnBoard(simBoard, move, player);
            return checkForWinForPlayerOnBoard(simBoard, player);
        }

        ////////////////////// AI SIMULATION HELPERS //////////////////////
        function cloneBoard(boardArg) {
            return boardArg.map(row => row.slice());
        }

        function applyGravitySim(simBoard) {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (simBoard[r][c]) {
                        stack.push(simBoard[r][c]);
                    }
                }
                for (let r = rows - 1; r >= 0; r--) {
                    simBoard[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        function simulateMoveOnBoard(simBoard, move, player) {
            if (move.type === 'drop') {
                for (let r = rows - 1; r >= 0; r--) {
                    if (!simBoard[r][move.index]) {
                        simBoard[r][move.index] = player;
                        break;
                    }
                }
            } else if (move.type === 'insertLeft') {
                let r = move.index;
                if (simBoard[r][0] === null) {
                    simBoard[r][0] = player;
                } else {
                    let end = 0;
                    while (end < cols && simBoard[r][end] !== null) {
                        end++;
                    }
                    if (end < cols) {
                        for (let i = end; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    } else {
                        for (let i = cols - 1; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    }
                    simBoard[r][0] = player;
                }
            } else if (move.type === 'insertRight') {
                let r = move.index;
                if (simBoard[r][cols - 1] === null) {
                    simBoard[r][cols - 1] = player;
                } else {
                    let start = cols - 1;
                    while (start >= 0 && simBoard[r][start] !== null) {
                        start--;
                    }
                    if (start >= 0) {
                        for (let i = start + 1; i < cols; i++) {
                            simBoard[r][i - 1] = simBoard[r][i];
                        }
                    } else {
                        for (let i = 0; i < cols - 1; i++) {
                            simBoard[r][i] = simBoard[r][i + 1];
                        }
                    }
                    simBoard[r][cols - 1] = player;
                }
            }
            applyGravitySim(simBoard);
        }

        function checkForWinForPlayerOnBoard(simBoard, player) {
            // Horizontal check
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r][c + 1] === player &&
                        simBoard[r][c + 2] === player &&
                        simBoard[r][c + 3] === player
                    )
                        return true;
                }
            }
            // Vertical check
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c] === player &&
                        simBoard[r + 2][c] === player &&
                        simBoard[r + 3][c] === player
                    )
                        return true;
                }
            }
            // Diagonal down-right check
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c + 1] === player &&
                        simBoard[r + 2][c + 2] === player &&
                        simBoard[r + 3][c + 3] === player
                    )
                        return true;
                }
            }
            // Diagonal down-left check
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c - 1] === player &&
                        simBoard[r + 2][c - 2] === player &&
                        simBoard[r + 3][c - 3] === player
                    )
                        return true;
                }
            }
            return false;
        }

        // Updated evaluation function for a window of 4 cells.
        function evaluateWindow(window) {
            let score = 0;
            const aiCount = window.filter(cell => cell === aiPlayer).length;
            const oppCount = window.filter(cell => cell === humanPlayer).length;
            const emptyCount = window.filter(cell => cell === null).length;

            if (aiCount > 0 && oppCount > 0) return 0;
            if (aiCount === 3 && emptyCount === 1) score += 500;
            if (oppCount === 3 && emptyCount === 1) score -= 500;
            if (aiCount === 4) score += 10000;
            if (oppCount === 4) score -= 10000;
            if (aiCount === 2 && emptyCount === 2) score += 10;
            if (oppCount === 2 && emptyCount === 2) score -= 5;
            return score;
        }

        function evaluateBoard(simBoard) {
            if (checkForWinForPlayerOnBoard(simBoard, aiPlayer)) return 10000;
            if (checkForWinForPlayerOnBoard(simBoard, humanPlayer)) return -10000;
            let score = 0;
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 3; c++) {
                    const window = [
                        simBoard[r][c],
                        simBoard[r][c + 1],
                        simBoard[r][c + 2],
                        simBoard[r][c + 3]
                    ];
                    score += evaluateWindow(window);
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 3; r++) {
                    const window = [
                        simBoard[r][c],
                        simBoard[r + 1][c],
                        simBoard[r + 2][c],
                        simBoard[r + 3][c]
                    ];
                    score += evaluateWindow(window);
                }
            }
            for (let r = 0; r < rows - 3; r++) {
                for (let c = 0; c < cols - 3; c++) {
                    const window = [
                        simBoard[r][c],
                        simBoard[r + 1][c + 1],
                        simBoard[r + 2][c + 2],
                        simBoard[r + 3][c + 3]
                    ];
                    score += evaluateWindow(window);
                }
            }
            for (let r = 0; r < rows - 3; r++) {
                for (let c = 3; c < cols; c++) {
                    const window = [
                        simBoard[r][c],
                        simBoard[r + 1][c - 1],
                        simBoard[r + 2][c - 2],
                        simBoard[r + 3][c - 3]
                    ];
                    score += evaluateWindow(window);
                }
            }
            return score;
        }

        // Minimax function with alpha-beta pruning and transposition table caching.
        function minimaxAlphaBeta(simBoard, depth, isMaximizing, alpha, beta) {
            const key = serializeBoard(simBoard) + "_" + depth + "_" + (isMaximizing ? "max" : "min");
            if (transpositionTable[key] !== undefined) return transpositionTable[key];
            if (checkForWinForPlayerOnBoard(simBoard, aiPlayer)) return 10000;
            if (checkForWinForPlayerOnBoard(simBoard, humanPlayer)) return -10000;
            if (depth === 0) return evaluateBoard(simBoard);

            let legal = getLegalMoves(simBoard);
            legal = orderMoves(legal, simBoard, isMaximizing, isMaximizing ? aiPlayer : humanPlayer);

            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, aiPlayer);
                    let evalScore = minimaxAlphaBeta(boardCopy, depth - 1, false, alpha, beta);
                    maxEval = Math.max(maxEval, evalScore);
                    alpha = Math.max(alpha, evalScore);
                    if (beta <= alpha) break;
                }
                transpositionTable[key] = maxEval;
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, humanPlayer);
                    let evalScore = minimaxAlphaBeta(boardCopy, depth - 1, true, alpha, beta);
                    minEval = Math.min(minEval, evalScore);
                    beta = Math.min(beta, evalScore);
                    if (beta <= alpha) break;
                }
                transpositionTable[key] = minEval;
                return minEval;
            }
        }

        // Fallback minimax (calls the alpha-beta version).
        function minimax(simBoard, depth, isMaximizing) {
            return minimaxAlphaBeta(simBoard, depth, isMaximizing, -Infinity, Infinity);
        }

        // Start the game when the page loads.
        startNewGame();
    </script>
</body>

</html>