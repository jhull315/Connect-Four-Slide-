<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connect Four: Slide!</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 30px;
            background: linear-gradient(135deg, #f0f8ff, #e6e6fa);
            min-height: 100vh;
        }
        
        #game {
            display: flex;
            flex-direction: row;
            align-items: center;
            position: relative;
        }
        
        #board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #columnButtons {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 4px;
            margin-bottom: 10px;
        }
        /* Ensure the board is relatively positioned so the SVG win-line can overlay it */
        
        #board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
            margin: 0;
            background-color: #1a1a1a;
            padding: 6px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #aaa 20%, #444);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease-in;
        }
        
        .player1 {
            background: red;
        }
        
        .player2 {
            background: blue;
        }
        
        button {
            margin: 2px;
            padding: 4px 8px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .row-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 0 10px;
            height: 100%;
        }
        
        .row-controls button {
            height: 50px;
            width: 50px;
            margin: 2px 0;
        }
        
        .arrow {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player1-btn {
            background-color: red;
            color: white;
        }
        
        .player2-btn {
            background-color: blue;
            color: white;
        }
        
        #status {
            margin: 10px;
            font-size: 1.2em;
        }
        /* AI Settings styling */
        
        #ai-settings {
            margin: 10px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
        }
        
        #rules {
            max-width: 700px;
            text-align: center;
            margin: 20px;
            font-size: 1em;
            line-height: 1.5em;
        }
    </style>
</head>

<body>
    <h2>Connect Four: Slide!</h2>
    <div id="board-container">
        <div class="controls" id="columnButtons"></div>
        <div id="game">
            <div class="row-controls" id="rowButtonsLeft"></div>
            <div id="board"></div>
            <div class="row-controls" id="rowButtonsRight"></div>
        </div>
    </div>
    <p id="status"></p>
    <button onclick="startNewGame()">New Game</button>
    <!-- AI Settings -->
    <div id="ai-settings">
        <label>
      <input type="checkbox" id="ai-toggle"> Play vs AI
    </label>
        <br/>
        <label>
      AI Difficulty: 
      <input type="range" id="ai-difficulty" min="1" max="5" value="3">
      <span id="ai-difficulty-value">3</span>
    </label>
        <br/>
        <!-- New option for human side -->
        <label>
      Human plays as:
      <select id="human-player">
        <option value="1">Player 1</option>
        <option value="2">Player 2</option>
      </select>
    </label>
    </div>
    <div id="rules">
        <p><strong>My personal version of Connect Four. Rules are as follows:</strong></p>
        <p>Just like regular Connect Four, four disks lined up in any direction is a win.</p>
        <p>However, disks can be inserted from either side of any row.</p>
        <p>Gravity is still in force, so if a disk is pushed to the side with nothing beneath it, it will fall.</p>
        <p>Empty spaces will be filled by sliding rows, and if the whole row is full, then a newly inserted disk will push the opposite end out of the game board.</p>
        <p>A win may come from any move, whether a drop in a column or a slide in a row, so watch for how things can change.</p>
        <p>Finally, if you make a move that causes a connected four for your opponent, your opponent wins. This is true even if your move creates your own connected four.</p>
        <p><em>New rule:</em> Repeating the same board state three times (back-and-forth moves) results in a draw (stalemate).</p>
    </div>
    <script>
        ////////////////////// Global Variables and Settings //////////////////////
        const rows = 6,
            cols = 7;
        let board;
        let currentPlayer;
        let winLineSvg = null;
        // AI settings: The human side can be chosen via a dropdown.
        let isAIEnabled = false;
        let aiDifficulty = 3; // 1 (random) … 5 (hardest)
        // Human and AI player numbers. Default: human = 1, AI = 2.
        let humanPlayer = 1,
            aiPlayer = 2;
        // Move history for repetition (stalemate) checking.
        let moveHistory = [];

        const boardDiv = document.getElementById('board');
        const status = document.getElementById('status');
        const colDiv = document.getElementById('columnButtons');
        const rowLeftDiv = document.getElementById('rowButtonsLeft');
        const rowRightDiv = document.getElementById('rowButtonsRight');

        // AI Settings event listeners.
        document.getElementById('ai-toggle').addEventListener('change', function() {
            isAIEnabled = this.checked;
        });
        document.getElementById('ai-difficulty').addEventListener('input', function() {
            aiDifficulty = parseInt(this.value);
            document.getElementById('ai-difficulty-value').textContent = this.value;
        });
        document.getElementById('human-player').addEventListener('change', function() {
            humanPlayer = parseInt(this.value);
            aiPlayer = 3 - humanPlayer;
        });

        ////////////////////// GAME INITIALIZATION AND RENDERING //////////////////////
        function startNewGame() {
            board = Array.from({
                length: rows
            }, () => Array(cols).fill(null));
            // Set humanPlayer based on UI and AI player accordingly.
            humanPlayer = parseInt(document.getElementById('human-player').value);
            aiPlayer = 3 - humanPlayer;
            currentPlayer = 1;
            if (winLineSvg) {
                winLineSvg.remove();
                winLineSvg = null;
            }
            moveHistory = [];
            setupButtons();
            update();
            status.textContent = `Player ${currentPlayer}'s turn`;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = false;
            });
            // If AI is enabled and it's the AI's turn, trigger AI move.
            if (isAIEnabled && currentPlayer === aiPlayer) {
                aiMakeMove();
            }
        }

        function createBoard() {
            boardDiv.innerHTML = '';
            if (winLineSvg) {
                boardDiv.appendChild(winLineSvg);
            }
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[r][c]) {
                        cell.classList.add(`player${board[r][c]}`);
                    }
                    boardDiv.appendChild(cell);
                }
            }
        }

        function applyGravity() {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (board[r][c]) stack.push(board[r][c]);
                }
                for (let r = rows - 1; r >= 0; r--) {
                    board[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        ////////////////////// MOVE FUNCTIONS //////////////////////
        function dropInColumn(col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = currentPlayer;
                    applyGravity();
                    checkAndSwitchTurn();
                    return;
                }
            }
            console.log("Column is full!");
        }

        function insertInRowLeft(row) {
            if (board[row][0] === null) {
                board[row][0] = currentPlayer;
            } else {
                let end = 0;
                while (end < cols && board[row][end] !== null) {
                    end++;
                }
                if (end < cols) {
                    for (let i = end; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                } else {
                    for (let i = cols - 1; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                }
                board[row][0] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        function insertInRowRight(row) {
            if (board[row][cols - 1] === null) {
                board[row][cols - 1] = currentPlayer;
            } else {
                let start = cols - 1;
                while (start >= 0 && board[row][start] !== null) {
                    start--;
                }
                if (start >= 0) {
                    for (let i = start + 1; i < cols; i++) {
                        board[row][i - 1] = board[row][i];
                    }
                } else {
                    for (let i = 0; i < cols - 1; i++) {
                        board[row][i] = board[row][i + 1];
                    }
                }
                board[row][cols - 1] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        ////////////////////// WIN CHECKING & WIN-LINE OVERLAY //////////////////////
        function checkForWinForPlayer(player) {
            // Horizontal check.
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r][c + 1] === player &&
                        board[r][c + 2] === player &&
                        board[r][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r, c + 1],
                                [r, c + 2],
                                [r, c + 3]
                            ]
                        };
                    }
                }
            }
            // Vertical check.
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c] === player &&
                        board[r + 2][c] === player &&
                        board[r + 3][c] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c],
                                [r + 2, c],
                                [r + 3, c]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-right.
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c + 1] === player &&
                        board[r + 2][c + 2] === player &&
                        board[r + 3][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c + 1],
                                [r + 2, c + 2],
                                [r + 3, c + 3]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-left.
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c - 1] === player &&
                        board[r + 2][c - 2] === player &&
                        board[r + 3][c - 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c - 1],
                                [r + 2, c - 2],
                                [r + 3, c - 3]
                            ]
                        };
                    }
                }
            }
            return null;
        }

        function displayWinLine(cells) {
            const firstCell = cells[0],
                lastCell = cells[cells.length - 1],
                x1 = 31 + firstCell[1] * 54,
                y1 = 31 + firstCell[0] * 54,
                x2 = 31 + lastCell[1] * 54,
                y2 = 31 + lastCell[0] * 54;

            const svgNS = "http://www.w3.org/2000/svg";
            winLineSvg = document.createElementNS(svgNS, "svg");
            winLineSvg.setAttribute("width", boardDiv.clientWidth);
            winLineSvg.setAttribute("height", boardDiv.clientHeight);
            winLineSvg.style.position = "absolute";
            winLineSvg.style.top = "0";
            winLineSvg.style.left = "0";

            const lineBorder = document.createElementNS(svgNS, "line");
            lineBorder.setAttribute("x1", x1);
            lineBorder.setAttribute("y1", y1);
            lineBorder.setAttribute("x2", x2);
            lineBorder.setAttribute("y2", y2);
            lineBorder.setAttribute("stroke", "black");
            lineBorder.setAttribute("stroke-width", "16");
            lineBorder.setAttribute("stroke-linecap", "round");

            const lineWhite = document.createElementNS(svgNS, "line");
            lineWhite.setAttribute("x1", x1);
            lineWhite.setAttribute("y1", y1);
            lineWhite.setAttribute("x2", x2);
            lineWhite.setAttribute("y2", y2);
            lineWhite.setAttribute("stroke", "white");
            lineWhite.setAttribute("stroke-width", "8");
            lineWhite.setAttribute("stroke-linecap", "round");

            winLineSvg.appendChild(lineBorder);
            winLineSvg.appendChild(lineWhite);
            boardDiv.appendChild(winLineSvg);
        }

        ////////////////////// REPETITION (STALEMATE) CHECK //////////////////////
        function serializeBoard() {
            return board.map(row => row.join(',')).join(';');
        }

        function updateHistory() {
            moveHistory.push(serializeBoard());
        }

        function checkForRepetition() {
            const current = serializeBoard();
            let count = 0;
            for (let state of moveHistory) {
                if (state === current) count++;
            }
            return count >= 3;
        }

        ////////////////////// TURN MANAGEMENT //////////////////////
        function checkAndSwitchTurn() {
            const winCurrent = checkForWinForPlayer(currentPlayer);
            const winOpponent = checkForWinForPlayer(3 - currentPlayer);
            if (winCurrent || winOpponent) {
                update();
                setTimeout(() => {
                    if (winOpponent) {
                        displayWinLine(winOpponent.cells);
                        status.textContent = `Player ${3 - currentPlayer} wins by trap!`;
                        disableButtons();
                    } else if (winCurrent) {
                        displayWinLine(winCurrent.cells);
                        status.textContent = `Player ${currentPlayer} wins!`;
                        disableButtons();
                    }
                }, 200);
                return;
            }

            updateHistory();
            if (checkForRepetition()) {
                status.textContent = "Game drawn by repetition (stalemate)!";
                disableButtons();
                return;
            }

            currentPlayer = 3 - currentPlayer;
            setupButtons();
            update();

            // Trigger AI move if it's AI's turn.
            if (isAIEnabled && currentPlayer === aiPlayer) {
                disableButtons(); // prevent human input during AI turn.
                aiMakeMove();
            }
        }

        function update() {
            createBoard();
            const btnClass = `player${currentPlayer}-btn`;
            document.querySelectorAll('.arrow').forEach(btn => {
                btn.className = `arrow ${btnClass}`;
            });
            if (!status.textContent.includes("wins")) {
                status.textContent = `Player ${currentPlayer}'s turn`;
            }
            // Disable controls if it's not the human's turn.
            if (isAIEnabled && currentPlayer !== humanPlayer) {
                document.querySelectorAll('.arrow').forEach(btn => btn.disabled = true);
            } else {
                document.querySelectorAll('.arrow').forEach(btn => btn.disabled = false);
            }
        }

        function disableButtons() {
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = true;
            });
        }

        function setupButtons() {
            colDiv.innerHTML = '';
            rowLeftDiv.innerHTML = '';
            rowRightDiv.innerHTML = '';

            for (let c = 0; c < cols; c++) {
                const btn = document.createElement('button');
                btn.innerHTML = '↓';
                btn.className = `arrow player${currentPlayer}-btn`;
                btn.onclick = () => dropInColumn(c);
                colDiv.appendChild(btn);
            }

            for (let r = 0; r < rows; r++) {
                const leftBtn = document.createElement('button');
                leftBtn.innerHTML = '→';
                leftBtn.className = `arrow player${currentPlayer}-btn`;
                leftBtn.onclick = () => insertInRowLeft(r);
                rowLeftDiv.appendChild(leftBtn);

                const rightBtn = document.createElement('button');
                rightBtn.innerHTML = '←';
                rightBtn.className = `arrow player${currentPlayer}-btn`;
                rightBtn.onclick = () => insertInRowRight(r);
                rowRightDiv.appendChild(rightBtn);
            }
        }

        ////////////////////// AI OPPONENT CODE //////////////////////
        function aiMakeMove() {
            setTimeout(() => {
                const move = chooseAIMove();
                if (move.type === 'drop') {
                    dropInColumn(move.index);
                } else if (move.type === 'insertLeft') {
                    insertInRowLeft(move.index);
                } else if (move.type === 'insertRight') {
                    insertInRowRight(move.index);
                }
            }, 500);
        }

        function getLegalMoves(simBoard) {
            let moves = [];
            for (let c = 0; c < cols; c++) {
                if (simBoard[0][c] === null) {
                    moves.push({
                        type: 'drop',
                        index: c
                    });
                }
            }
            for (let r = 0; r < rows; r++) {
                moves.push({
                    type: 'insertLeft',
                    index: r
                });
                moves.push({
                    type: 'insertRight',
                    index: r
                });
            }
            return moves;
        }

        // Choose an AI move based on difficulty.
        function chooseAIMove() {
            let legalMoves = getLegalMoves(board);

            // Always take an immediate winning move.
            for (let move of legalMoves) {
                if (simulateAndCheckWin(move, aiPlayer)) {
                    return move;
                }
            }

            if (aiDifficulty === 1) {
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 2 || aiDifficulty === 3) {
                let oppLegalMoves = [];
                // Level 2: consider only drop moves.
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === null) {
                        oppLegalMoves.push({
                            type: 'drop',
                            index: c
                        });
                    }
                }
                // Level 3: also consider insert moves.
                if (aiDifficulty === 3) {
                    for (let r = 0; r < rows; r++) {
                        oppLegalMoves.push({
                            type: 'insertLeft',
                            index: r
                        });
                        oppLegalMoves.push({
                            type: 'insertRight',
                            index: r
                        });
                    }
                }
                let opponentWinningMoves = [];
                for (let oppMove of oppLegalMoves) {
                    if (simulateAndCheckWin(oppMove, humanPlayer)) {
                        opponentWinningMoves.push(oppMove);
                    }
                }
                let candidateMoves = [];
                for (let candidate of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, candidate, aiPlayer);
                    let blocks = true;
                    for (let oppMove of opponentWinningMoves) {
                        let sim2 = cloneBoard(sim);
                        simulateMoveOnBoard(sim2, oppMove, humanPlayer);
                        if (checkForWinForPlayerOnBoard(sim2, humanPlayer)) {
                            blocks = false;
                            break;
                        }
                    }
                    if (blocks) candidateMoves.push(candidate);
                }
                if (candidateMoves.length > 0) {
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 4 || aiDifficulty === 5) {
                let depth = (aiDifficulty === 4 ? 2 : 3);
                let bestScore = -Infinity;
                let bestMoves = [];
                for (let move of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, move, aiPlayer);
                    let score = minimax(sim, depth, false);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        }

        ////////////////////// AI SIMULATION HELPERS //////////////////////
        function cloneBoard(board) {
            return board.map(row => row.slice());
        }

        function applyGravitySim(simBoard) {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (simBoard[r][c]) stack.push(simBoard[r][c]);
                }
                for (let r = rows - 1; r >= 0; r--) {
                    simBoard[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        function simulateMoveOnBoard(simBoard, move, player) {
            if (move.type === 'drop') {
                for (let r = rows - 1; r >= 0; r--) {
                    if (!simBoard[r][move.index]) {
                        simBoard[r][move.index] = player;
                        break;
                    }
                }
            } else if (move.type === 'insertLeft') {
                let r = move.index;
                if (simBoard[r][0] === null) {
                    simBoard[r][0] = player;
                } else {
                    let end = 0;
                    while (end < cols && simBoard[r][end] !== null) {
                        end++;
                    }
                    if (end < cols) {
                        for (let i = end; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    } else {
                        for (let i = cols - 1; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    }
                    simBoard[r][0] = player;
                }
            } else if (move.type === 'insertRight') {
                let r = move.index;
                if (simBoard[r][cols - 1] === null) {
                    simBoard[r][cols - 1] = player;
                } else {
                    let start = cols - 1;
                    while (start >= 0 && simBoard[r][start] !== null) {
                        start--;
                    }
                    if (start >= 0) {
                        for (let i = start + 1; i < cols; i++) {
                            simBoard[r][i - 1] = simBoard[r][i];
                        }
                    } else {
                        for (let i = 0; i < cols - 1; i++) {
                            simBoard[r][i] = simBoard[r][i + 1];
                        }
                    }
                    simBoard[r][cols - 1] = player;
                }
            }
            applyGravitySim(simBoard);
        }

        function checkForWinForPlayerOnBoard(simBoard, player) {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r][c + 1] === player &&
                        simBoard[r][c + 2] === player &&
                        simBoard[r][c + 3] === player
                    ) return true;
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c] === player &&
                        simBoard[r + 2][c] === player &&
                        simBoard[r + 3][c] === player
                    ) return true;
                }
            }
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c + 1] === player &&
                        simBoard[r + 2][c + 2] === player &&
                        simBoard[r + 3][c + 3] === player
                    ) return true;
                }
            }
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c - 1] === player &&
                        simBoard[r + 2][c - 2] === player &&
                        simBoard[r + 3][c - 3] === player
                    ) return true;
                }
            }
            return false;
        }

        function simulateAndCheckWin(move, player) {
            const simBoard = cloneBoard(board);
            simulateMoveOnBoard(simBoard, move, player);
            return checkForWinForPlayerOnBoard(simBoard, player);
        }

        // Enhanced evaluation function that, for level 5 AI, also checks for trap scenarios.
        function evaluateBoard(simBoard) {
            // If playing level 5 AI, if both sides appear to win then it's a trap (bad for AI).
            if (aiDifficulty === 5) {
                if (checkForWinForPlayerOnBoard(simBoard, aiPlayer) && checkForWinForPlayerOnBoard(simBoard, humanPlayer))
                    return -10000;
                if (checkForWinForPlayerOnBoard(simBoard, aiPlayer)) return 10000;
                if (checkForWinForPlayerOnBoard(simBoard, humanPlayer)) return -10000;
            } else {
                if (checkForWinForPlayerOnBoard(simBoard, aiPlayer)) return 10000;
                if (checkForWinForPlayerOnBoard(simBoard, humanPlayer)) return -10000;
            }
            let score = 0;
            // Evaluate horizontal windows.
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols - 3; c++) {
                    const window = [simBoard[r][c], simBoard[r][c + 1], simBoard[r][c + 2], simBoard[r][c + 3]];
                    score += evaluateWindow(window);
                }
            }
            // Evaluate vertical windows.
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r < rows - 3; r++) {
                    const window = [simBoard[r][c], simBoard[r + 1][c], simBoard[r + 2][c], simBoard[r + 3][c]];
                    score += evaluateWindow(window);
                }
            }
            // Evaluate diagonal down-right windows.
            for (let r = 0; r < rows - 3; r++) {
                for (let c = 0; c < cols - 3; c++) {
                    const window = [simBoard[r][c], simBoard[r + 1][c + 1], simBoard[r + 2][c + 2], simBoard[r + 3][c + 3]];
                    score += evaluateWindow(window);
                }
            }
            // Evaluate diagonal down-left windows.
            for (let r = 0; r < rows - 3; r++) {
                for (let c = 3; c < cols; c++) {
                    const window = [simBoard[r][c], simBoard[r + 1][c - 1], simBoard[r + 2][c - 2], simBoard[r + 3][c - 3]];
                    score += evaluateWindow(window);
                }
            }
            return score;
        }

        function evaluateWindow(window) {
            let score = 0;
            const aiCount = window.filter(cell => cell === aiPlayer).length;
            const oppCount = window.filter(cell => cell === humanPlayer).length;
            const emptyCount = window.filter(cell => cell === null).length;

            // If both are present, ignore this window.
            if (aiCount > 0 && oppCount > 0) return 0;

            if (aiCount === 4) score += 10000;
            else if (aiCount === 3 && emptyCount === 1) score += 100;
            else if (aiCount === 2 && emptyCount === 2) score += 10;

            if (oppCount === 4) score -= 10000;
            else if (oppCount === 3 && emptyCount === 1) score -= 80;
            else if (oppCount === 2 && emptyCount === 2) score -= 5;

            return score;
        }

        function minimax(simBoard, depth, isMaximizing) {
            if (checkForWinForPlayerOnBoard(simBoard, aiPlayer)) return 10000;
            if (checkForWinForPlayerOnBoard(simBoard, humanPlayer)) return -10000;
            if (depth === 0) return evaluateBoard(simBoard);

            const legal = getLegalMoves(simBoard);
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, aiPlayer);
                    let eval = minimax(boardCopy, depth - 1, false);
                    maxEval = Math.max(maxEval, eval);
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, humanPlayer);
                    let eval = minimax(boardCopy, depth - 1, true);
                    minEval = Math.min(minEval, eval);
                }
                return minEval;
            }
        }

        function chooseAIMove() {
            let legalMoves = getLegalMoves(board);

            // Always take an immediate winning move.
            for (let move of legalMoves) {
                if (simulateAndCheckWin(move, aiPlayer)) {
                    return move;
                }
            }

            if (aiDifficulty === 1) {
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 2 || aiDifficulty === 3) {
                let oppLegalMoves = [];
                // Level 2: only drop moves.
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === null) {
                        oppLegalMoves.push({
                            type: 'drop',
                            index: c
                        });
                    }
                }
                // Level 3: also include insert moves.
                if (aiDifficulty === 3) {
                    for (let r = 0; r < rows; r++) {
                        oppLegalMoves.push({
                            type: 'insertLeft',
                            index: r
                        });
                        oppLegalMoves.push({
                            type: 'insertRight',
                            index: r
                        });
                    }
                }
                let opponentWinningMoves = [];
                for (let oppMove of oppLegalMoves) {
                    if (simulateAndCheckWin(oppMove, humanPlayer)) {
                        opponentWinningMoves.push(oppMove);
                    }
                }
                let candidateMoves = [];
                for (let candidate of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, candidate, aiPlayer);
                    let blocks = true;
                    for (let oppMove of opponentWinningMoves) {
                        let sim2 = cloneBoard(sim);
                        simulateMoveOnBoard(sim2, oppMove, humanPlayer);
                        if (checkForWinForPlayerOnBoard(sim2, humanPlayer)) {
                            blocks = false;
                            break;
                        }
                    }
                    if (blocks) candidateMoves.push(candidate);
                }
                if (candidateMoves.length > 0) {
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 4 || aiDifficulty === 5) {
                let depth = (aiDifficulty === 4 ? 2 : 3);
                let bestScore = -Infinity;
                let bestMoves = [];
                for (let move of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, move, aiPlayer);
                    let score = minimax(sim, depth, false);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        }

        function simulateAndCheckWin(move, player) {
            const simBoard = cloneBoard(board);
            simulateMoveOnBoard(simBoard, move, player);
            return checkForWinForPlayerOnBoard(simBoard, player);
        }

        // ----- MAIN: START GAME ON LOAD -----
        startNewGame();
    </script>
</body>

</html>