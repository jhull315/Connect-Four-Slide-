<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connect Four: Slide!</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 30px;
            background: linear-gradient(135deg, #f0f8ff, #e6e6fa);
            min-height: 100vh;
        }
        
        #game {
            display: flex;
            flex-direction: row;
            align-items: center;
            position: relative;
        }
        
        #board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #columnButtons {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 4px;
            margin-bottom: 10px;
        }
        /* Ensure board is positioned relative so the SVG overlay can be absolute */
        
        #board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
            margin: 0;
            background-color: #1a1a1a;
            padding: 6px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #aaa 20%, #444);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease-in;
        }
        
        .player1 {
            background: red;
        }
        
        .player2 {
            background: blue;
        }
        
        button {
            margin: 2px;
            padding: 4px 8px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .row-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 0 10px;
            height: 100%;
        }
        
        .row-controls button {
            height: 50px;
            width: 50px;
            margin: 2px 0;
        }
        
        .arrow {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player1-btn {
            background-color: red;
            color: white;
        }
        
        .player2-btn {
            background-color: blue;
            color: white;
        }
        
        #status {
            margin: 10px;
            font-size: 1.2em;
        }
        
        #rules {
            max-width: 700px;
            text-align: center;
            margin: 20px;
            font-size: 1em;
            line-height: 1.5em;
        }
    </style>
</head>

<body>
    <h2>Connect Four: Slide!</h2>
    <div id="board-container">
        <div class="controls" id="columnButtons"></div>
        <div id="game">
            <div class="row-controls" id="rowButtonsLeft"></div>
            <div id="board"></div>
            <div class="row-controls" id="rowButtonsRight"></div>
        </div>
    </div>
    <p id="status"></p>
    <button onclick="startNewGame()">New Game</button>
    <div id="rules">
        <p><strong>My personal version of Connect Four. Rules are as follows:</strong></p>
        <p>Just like regular Connect Four, four disks lined up in any direction is a win.</p>
        <p>However, disks can be inserted from either side of any row.</p>
        <p>Gravity is still in force, so if a disk is pushed to the side with nothing beneath it, it will fall.</p>
        <p>Empty spaces will be filled by sliding rows, and if the whole row is full, then a newly inserted disk will push the opposite end out of the game board.</p>
        <p>A win may come from any move, whether a drop in a column or a slide in a row, so watch for how things can change.</p>
        <p>Finally, if you make a move that causes a connected four for your opponent, your opponent wins. This is true even if your move creates your own connected four.</p>
    </div>
    <script>
        const rows = 6,
            cols = 7;
        let board;
        let currentPlayer;
        // Global variable to store the SVG win overlay (if any).
        let winLineSvg = null;
        const boardDiv = document.getElementById('board');
        const status = document.getElementById('status');
        const colDiv = document.getElementById('columnButtons');
        const rowLeftDiv = document.getElementById('rowButtonsLeft');
        const rowRightDiv = document.getElementById('rowButtonsRight');

        function startNewGame() {
            // Initialize the board as a 2D array with all null values.
            board = Array.from({
                length: rows
            }, () => Array(cols).fill(null));
            currentPlayer = 1;
            // If an SVG win line exists from previous game, remove it.
            if (winLineSvg) {
                winLineSvg.remove();
                winLineSvg = null;
            }
            setupButtons();
            update();
            // Display whose turn it is.
            status.textContent = `Player ${currentPlayer}'s turn`;
            // Enable all move buttons (the "New Game" button remains enabled).
            document.querySelectorAll('button').forEach(btn => btn.disabled = false);
        }

        function createBoard() {
            boardDiv.innerHTML = '';
            // If a win line already exists (when starting a new game, it will be removed),
            // re-add it so that it remains visible on top of the board.
            if (winLineSvg) {
                boardDiv.appendChild(winLineSvg);
            }
            // Render each cell on the board.
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[r][c]) {
                        cell.classList.add(`player${board[r][c]}`);
                    }
                    boardDiv.appendChild(cell);
                }
            }
        }

        function applyGravity() {
            // For each column, gather all disks in a stack and "drop" them into place.
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (board[r][c]) stack.push(board[r][c]);
                }
                for (let r = rows - 1; r >= 0; r--) {
                    board[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        function dropInColumn(col) {
            // Drop a disk into the specified column (scanning from the bottom).
            for (let r = rows - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = currentPlayer;
                    applyGravity();
                    checkAndSwitchTurn();
                    return;
                }
            }
            console.log("Column is full!");
        }

        function insertInRowLeft(row) {
            // Inserts a disk from the left side into the given row.
            if (board[row][0] === null) {
                board[row][0] = currentPlayer;
            } else {
                // Identify the contiguous block of disks from the left edge.
                let end = 0;
                while (end < cols && board[row][end] !== null) {
                    end++;
                }
                if (end < cols) {
                    // Shift the block right by one cell.
                    for (let i = end; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                } else {
                    // If the row is full, shift the entire row right (pushing off the rightmost disk).
                    for (let i = cols - 1; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                }
                board[row][0] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        function insertInRowRight(row) {
            // Inserts a disk from the right side into the given row.
            if (board[row][cols - 1] === null) {
                board[row][cols - 1] = currentPlayer;
            } else {
                // Identify the contiguous block of disks from the right edge.
                let start = cols - 1;
                while (start >= 0 && board[row][start] !== null) {
                    start--;
                }
                if (start >= 0) {
                    // Shift the block left by one cell.
                    for (let i = start + 1; i < cols; i++) {
                        board[row][i - 1] = board[row][i];
                    }
                } else {
                    // If the row is full, shift the entire row left (pushing off the leftmost disk).
                    for (let i = 0; i < cols - 1; i++) {
                        board[row][i] = board[row][i + 1];
                    }
                }
                board[row][cols - 1] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        // Returns an object with the winning player's number and an array of the winning cells
        // (as [row, col] pairs) if the specified player has four aligned disks; otherwise returns null.
        function checkForWinForPlayer(player) {
            // Horizontal check.
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r][c + 1] === player &&
                        board[r][c + 2] === player &&
                        board[r][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r, c + 1],
                                [r, c + 2],
                                [r, c + 3]
                            ]
                        };
                    }
                }
            }
            // Vertical check.
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c] === player &&
                        board[r + 2][c] === player &&
                        board[r + 3][c] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c],
                                [r + 2, c],
                                [r + 3, c]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-right check.
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c + 1] === player &&
                        board[r + 2][c + 2] === player &&
                        board[r + 3][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c + 1],
                                [r + 2, c + 2],
                                [r + 3, c + 3]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-left check.
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c - 1] === player &&
                        board[r + 2][c - 2] === player &&
                        board[r + 3][c - 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c - 1],
                                [r + 2, c - 2],
                                [r + 3, c - 3]
                            ]
                        };
                    }
                }
            }
            return null;
        }

        // Creates an SVG overlay with a slashing line that passes through the centers of the winning cells.
        function displayWinLine(cells) {
            // With board padding (6px), cell size (50px) and gap (4px):
            // The center of cell at row r, col c is: x = 6 + 25 + c*(50+4) = 31 + 54*c,
            // and similarly y = 31 + 54*r.
            const firstCell = cells[0],
                lastCell = cells[cells.length - 1],
                x1 = 31 + firstCell[1] * 54,
                y1 = 31 + firstCell[0] * 54,
                x2 = 31 + lastCell[1] * 54,
                y2 = 31 + lastCell[0] * 54;

            const svgNS = "http://www.w3.org/2000/svg";
            // Create an SVG element covering the board.
            winLineSvg = document.createElementNS(svgNS, "svg");
            winLineSvg.setAttribute("width", boardDiv.clientWidth);
            winLineSvg.setAttribute("height", boardDiv.clientHeight);
            winLineSvg.style.position = "absolute";
            winLineSvg.style.top = "0";
            winLineSvg.style.left = "0";

            // Create a thick black line as a border.
            const lineBorder = document.createElementNS(svgNS, "line");
            lineBorder.setAttribute("x1", x1);
            lineBorder.setAttribute("y1", y1);
            lineBorder.setAttribute("x2", x2);
            lineBorder.setAttribute("y2", y2);
            lineBorder.setAttribute("stroke", "black");
            lineBorder.setAttribute("stroke-width", "16");
            lineBorder.setAttribute("stroke-linecap", "round");

            // Create a thinner white line on top.
            const lineWhite = document.createElementNS(svgNS, "line");
            lineWhite.setAttribute("x1", x1);
            lineWhite.setAttribute("y1", y1);
            lineWhite.setAttribute("x2", x2);
            lineWhite.setAttribute("y2", y2);
            lineWhite.setAttribute("stroke", "white");
            lineWhite.setAttribute("stroke-width", "8");
            lineWhite.setAttribute("stroke-linecap", "round");

            winLineSvg.appendChild(lineBorder);
            winLineSvg.appendChild(lineWhite);
            boardDiv.appendChild(winLineSvg);
        }

        // Checks for wins after a move. It first ensures that the final move is visible,
        // then after a short delay, overlays the win line and announces the winner.
        function checkAndSwitchTurn() {
            // Check for a win for both the current player and the opponent.
            const winCurrent = checkForWinForPlayer(currentPlayer);
            const winOpponent = checkForWinForPlayer(3 - currentPlayer);
            if (winCurrent || winOpponent) {
                // Update the board so that the new move is clearly visible.
                update();
                setTimeout(() => {
                    // If a move causes a win for the opponent, the opponent wins by trap.
                    if (winOpponent) {
                        displayWinLine(winOpponent.cells);
                        status.textContent = `Player ${3 - currentPlayer} wins by trap!`;
                        disableButtons();
                    }
                    // Otherwise, the current player wins.
                    else if (winCurrent) {
                        displayWinLine(winCurrent.cells);
                        status.textContent = `Player ${currentPlayer} wins!`;
                        disableButtons();
                    }
                }, 200); // Allow 200ms for the final move to settle visually.
                return;
            }
            // No win: switch players.
            currentPlayer = 3 - currentPlayer;
            setupButtons();
            update();
        }

        function update() {
            createBoard();
            // Update arrow button colors to the current player's color.
            const btnClass = `player${currentPlayer}-btn`;
            document.querySelectorAll('.arrow').forEach(btn => {
                btn.className = `arrow ${btnClass}`;
            });
            // If no win message is active, display whose turn it is.
            if (!status.textContent.includes("wins")) {
                status.textContent = `Player ${currentPlayer}'s turn`;
            }
        }

        function disableButtons() {
            // Disable all buttons except the "New Game" button.
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = true;
            });
        }

        function setupButtons() {
            colDiv.innerHTML = '';
            rowLeftDiv.innerHTML = '';
            rowRightDiv.innerHTML = '';

            // Create drop buttons for each column.
            for (let c = 0; c < cols; c++) {
                const btn = document.createElement('button');
                btn.innerHTML = '↓';
                btn.className = `arrow player${currentPlayer}-btn`;
                btn.onclick = () => dropInColumn(c);
                colDiv.appendChild(btn);
            }

            // Create slide buttons for each row.
            for (let r = 0; r < rows; r++) {
                const leftBtn = document.createElement('button');
                leftBtn.innerHTML = '→';
                leftBtn.className = `arrow player${currentPlayer}-btn`;
                leftBtn.onclick = () => insertInRowLeft(r);
                rowLeftDiv.appendChild(leftBtn);

                const rightBtn = document.createElement('button');
                rightBtn.innerHTML = '←';
                rightBtn.className = `arrow player${currentPlayer}-btn`;
                rightBtn.onclick = () => insertInRowRight(r);
                rowRightDiv.appendChild(rightBtn);
            }
        }

        // Start a new game when the page loads.
        startNewGame();
    </script>
</body>

</html>