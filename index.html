<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Connect Four: Slide!</title>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-top: 30px;
            background: linear-gradient(135deg, #f0f8ff, #e6e6fa);
            min-height: 100vh;
        }
        
        #game {
            display: flex;
            flex-direction: row;
            align-items: center;
            position: relative;
        }
        
        #board-container {
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        
        #columnButtons {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            gap: 4px;
            margin-bottom: 10px;
        }
        /* The board is relatively positioned so that the SVG win-line can overlay it */
        
        #board {
            display: grid;
            grid-template-columns: repeat(7, 50px);
            grid-template-rows: repeat(6, 50px);
            gap: 4px;
            margin: 0;
            background-color: #1a1a1a;
            padding: 6px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            position: relative;
        }
        
        .cell {
            width: 50px;
            height: 50px;
            background: radial-gradient(circle at center, #aaa 20%, #444);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: transform 0.3s ease-in;
        }
        
        .player1 {
            background: red;
        }
        
        .player2 {
            background: blue;
        }
        
        button {
            margin: 2px;
            padding: 4px 8px;
            cursor: pointer;
            border: none;
            border-radius: 4px;
            font-weight: bold;
        }
        
        .controls {
            display: flex;
            justify-content: center;
            margin-bottom: 10px;
        }
        
        .row-controls {
            display: flex;
            flex-direction: column;
            justify-content: center;
            margin: 0 10px;
            height: 100%;
        }
        
        .row-controls button {
            height: 50px;
            width: 50px;
            margin: 2px 0;
        }
        
        .arrow {
            width: 40px;
            height: 40px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .player1-btn {
            background-color: red;
            color: white;
        }
        
        .player2-btn {
            background-color: blue;
            color: white;
        }
        
        #status {
            margin: 10px;
            font-size: 1.2em;
        }
        /* AI Settings styling */
        
        #ai-settings {
            margin: 10px;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 8px;
            background: #fff;
        }
        
        #rules {
            max-width: 700px;
            text-align: center;
            margin: 20px;
            font-size: 1em;
            line-height: 1.5em;
        }
    </style>
</head>

<body>
    <h2>Connect Four: Slide!</h2>
    <div id="board-container">
        <div class="controls" id="columnButtons"></div>
        <div id="game">
            <div class="row-controls" id="rowButtonsLeft"></div>
            <div id="board"></div>
            <div class="row-controls" id="rowButtonsRight"></div>
        </div>
    </div>
    <p id="status"></p>
    <button onclick="startNewGame()">New Game</button>
    <!-- AI Settings -->
    <div id="ai-settings">
        <label>
      <input type="checkbox" id="ai-toggle"> Play vs AI (Computer is always Player 2)
    </label>
        <br/>
        <label>
      AI Difficulty: 
      <input type="range" id="ai-difficulty" min="1" max="5" value="3">
      <span id="ai-difficulty-value">3</span>
    </label>
    </div>
    <div id="rules">
        <p><strong>My personal version of Connect Four. Rules are as follows:</strong></p>
        <p>Just like regular Connect Four, four disks lined up in any direction is a win.</p>
        <p>However, disks can be inserted from either side of any row.</p>
        <p>Gravity is still in force, so if a disk is pushed to the side with nothing beneath it, it will fall.</p>
        <p>Empty spaces will be filled by sliding rows, and if the whole row is full, then a newly inserted disk will push the opposite end out of the game board.</p>
        <p>A win may come from any move, whether a drop in a column or a slide in a row, so watch for how things can change.</p>
        <p>Finally, if you make a move that causes a connected four for your opponent, your opponent wins. This is true even if your move creates your own connected four.</p>
        <p><em>New stalemate rule:</em> Repeating the same moves back and forth (i.e. producing the same board state three times) results in a drawn game.</p>
    </div>
    <script>
        // Global constants and variables.
        const rows = 6,
            cols = 7;
        let board;
        let currentPlayer;
        let winLineSvg = null;
        // AI settings: AI is always Player 2.
        let isAIEnabled = false;
        let aiDifficulty = 3; // Levels: 1 (random) to 5 (hardest)
        // Global move history to check for repetition (each state is serialized as a string).
        let moveHistory = [];

        const boardDiv = document.getElementById('board');
        const status = document.getElementById('status');
        const colDiv = document.getElementById('columnButtons');
        const rowLeftDiv = document.getElementById('rowButtonsLeft');
        const rowRightDiv = document.getElementById('rowButtonsRight');

        // AI Settings event listeners.
        document.getElementById('ai-toggle').addEventListener('change', function() {
            isAIEnabled = this.checked;
        });
        document.getElementById('ai-difficulty').addEventListener('input', function() {
            aiDifficulty = parseInt(this.value);
            document.getElementById('ai-difficulty-value').textContent = this.value;
        });

        function startNewGame() {
            // Initialize the board as a 2D array (all cells null).
            board = Array.from({
                length: rows
            }, () => Array(cols).fill(null));
            currentPlayer = 1;
            // Clear any previous win overlay.
            if (winLineSvg) {
                winLineSvg.remove();
                winLineSvg = null;
            }
            // Clear move history.
            moveHistory = [];

            setupButtons();
            update();
            status.textContent = `Player ${currentPlayer}'s turn`;
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') {
                    btn.disabled = false;
                }
            });

            // If AI is enabled and it's AI's turn (Player 2), then trigger the AI move.
            if (isAIEnabled && currentPlayer === 2) {
                aiMakeMove();
            }
        }

        function createBoard() {
            boardDiv.innerHTML = '';
            // If a win line exists, re-add it.
            if (winLineSvg) {
                boardDiv.appendChild(winLineSvg);
            }
            // Render the board cells.
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'cell';
                    if (board[r][c]) {
                        cell.classList.add(`player${board[r][c]}`);
                    }
                    boardDiv.appendChild(cell);
                }
            }
        }

        function applyGravity() {
            // For each column, collect all disks and drop them to the bottom.
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (board[r][c]) stack.push(board[r][c]);
                }
                for (let r = rows - 1; r >= 0; r--) {
                    board[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        function dropInColumn(col) {
            for (let r = rows - 1; r >= 0; r--) {
                if (!board[r][col]) {
                    board[r][col] = currentPlayer;
                    applyGravity();
                    checkAndSwitchTurn();
                    return;
                }
            }
            console.log("Column is full!");
        }

        function insertInRowLeft(row) {
            if (board[row][0] === null) {
                board[row][0] = currentPlayer;
            } else {
                let end = 0;
                while (end < cols && board[row][end] !== null) {
                    end++;
                }
                if (end < cols) {
                    for (let i = end; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                } else {
                    for (let i = cols - 1; i > 0; i--) {
                        board[row][i] = board[row][i - 1];
                    }
                }
                board[row][0] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        function insertInRowRight(row) {
            if (board[row][cols - 1] === null) {
                board[row][cols - 1] = currentPlayer;
            } else {
                let start = cols - 1;
                while (start >= 0 && board[row][start] !== null) {
                    start--;
                }
                if (start >= 0) {
                    for (let i = start + 1; i < cols; i++) {
                        board[row][i - 1] = board[row][i];
                    }
                } else {
                    for (let i = 0; i < cols - 1; i++) {
                        board[row][i] = board[row][i + 1];
                    }
                }
                board[row][cols - 1] = currentPlayer;
            }
            applyGravity();
            checkAndSwitchTurn();
        }

        // --- WIN CHECKING AND WIN-LINE OVERLAY ---
        function checkForWinForPlayer(player) {
            // Horizontal
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r][c + 1] === player &&
                        board[r][c + 2] === player &&
                        board[r][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r, c + 1],
                                [r, c + 2],
                                [r, c + 3]
                            ]
                        };
                    }
                }
            }
            // Vertical
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c] === player &&
                        board[r + 2][c] === player &&
                        board[r + 3][c] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c],
                                [r + 2, c],
                                [r + 3, c]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-right
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c + 1] === player &&
                        board[r + 2][c + 2] === player &&
                        board[r + 3][c + 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c + 1],
                                [r + 2, c + 2],
                                [r + 3, c + 3]
                            ]
                        };
                    }
                }
            }
            // Diagonal down-left
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        board[r][c] === player &&
                        board[r + 1][c - 1] === player &&
                        board[r + 2][c - 2] === player &&
                        board[r + 3][c - 3] === player
                    ) {
                        return {
                            winner: player,
                            cells: [
                                [r, c],
                                [r + 1, c - 1],
                                [r + 2, c - 2],
                                [r + 3, c - 3]
                            ]
                        };
                    }
                }
            }
            return null;
        }

        function displayWinLine(cells) {
            // Calculate the centers of the winning cells.
            const firstCell = cells[0],
                lastCell = cells[cells.length - 1],
                x1 = 31 + firstCell[1] * 54,
                y1 = 31 + firstCell[0] * 54,
                x2 = 31 + lastCell[1] * 54,
                y2 = 31 + lastCell[0] * 54;

            const svgNS = "http://www.w3.org/2000/svg";
            winLineSvg = document.createElementNS(svgNS, "svg");
            winLineSvg.setAttribute("width", boardDiv.clientWidth);
            winLineSvg.setAttribute("height", boardDiv.clientHeight);
            winLineSvg.style.position = "absolute";
            winLineSvg.style.top = "0";
            winLineSvg.style.left = "0";

            const lineBorder = document.createElementNS(svgNS, "line");
            lineBorder.setAttribute("x1", x1);
            lineBorder.setAttribute("y1", y1);
            lineBorder.setAttribute("x2", x2);
            lineBorder.setAttribute("y2", y2);
            lineBorder.setAttribute("stroke", "black");
            lineBorder.setAttribute("stroke-width", "16");
            lineBorder.setAttribute("stroke-linecap", "round");

            const lineWhite = document.createElementNS(svgNS, "line");
            lineWhite.setAttribute("x1", x1);
            lineWhite.setAttribute("y1", y1);
            lineWhite.setAttribute("x2", x2);
            lineWhite.setAttribute("y2", y2);
            lineWhite.setAttribute("stroke", "white");
            lineWhite.setAttribute("stroke-width", "8");
            lineWhite.setAttribute("stroke-linecap", "round");

            winLineSvg.appendChild(lineBorder);
            winLineSvg.appendChild(lineWhite);
            boardDiv.appendChild(winLineSvg);
        }

        // --- MOVE REPETITION (STALEMATE) RULE ---
        // Serialize the board state into a string.
        function serializeBoard() {
            return board.map(row => row.join(',')).join(';');
        }
        // Add the current board state to history.
        function updateHistory() {
            moveHistory.push(serializeBoard());
        }
        // Check if the current board state has appeared at least three times.
        function checkForRepetition() {
            const current = serializeBoard();
            let count = 0;
            for (let state of moveHistory) {
                if (state === current) {
                    count++;
                }
            }
            return count >= 3;
        }

        // --- TURN MANAGEMENT ---
        function checkAndSwitchTurn() {
            const winCurrent = checkForWinForPlayer(currentPlayer);
            const winOpponent = checkForWinForPlayer(3 - currentPlayer);
            if (winCurrent || winOpponent) {
                update();
                setTimeout(() => {
                    if (winOpponent) {
                        displayWinLine(winOpponent.cells);
                        status.textContent = `Player ${3 - currentPlayer} wins by trap!`;
                        disableButtons();
                    } else if (winCurrent) {
                        displayWinLine(winCurrent.cells);
                        status.textContent = `Player ${currentPlayer} wins!`;
                        disableButtons();
                    }
                }, 200);
                return;
            }

            // Update move history and check for repetition.
            updateHistory();
            if (checkForRepetition()) {
                status.textContent = "Game drawn by repetition!";
                disableButtons();
                return;
            }

            currentPlayer = 3 - currentPlayer;
            setupButtons();
            update();
            if (isAIEnabled && currentPlayer === 2) {
                aiMakeMove();
            }
        }

        function update() {
            createBoard();
            const btnClass = `player${currentPlayer}-btn`;
            document.querySelectorAll('.arrow').forEach(btn => {
                btn.className = `arrow ${btnClass}`;
            });
            if (!status.textContent.includes("wins")) {
                status.textContent = `Player ${currentPlayer}'s turn`;
            }
        }

        function disableButtons() {
            document.querySelectorAll('button').forEach(btn => {
                if (btn.textContent !== 'New Game') btn.disabled = true;
            });
        }

        function setupButtons() {
            colDiv.innerHTML = '';
            rowLeftDiv.innerHTML = '';
            rowRightDiv.innerHTML = '';

            for (let c = 0; c < cols; c++) {
                const btn = document.createElement('button');
                btn.innerHTML = '↓';
                btn.className = `arrow player${currentPlayer}-btn`;
                btn.onclick = () => dropInColumn(c);
                colDiv.appendChild(btn);
            }

            for (let r = 0; r < rows; r++) {
                const leftBtn = document.createElement('button');
                leftBtn.innerHTML = '→';
                leftBtn.className = `arrow player${currentPlayer}-btn`;
                leftBtn.onclick = () => insertInRowLeft(r);
                rowLeftDiv.appendChild(leftBtn);

                const rightBtn = document.createElement('button');
                rightBtn.innerHTML = '←';
                rightBtn.className = `arrow player${currentPlayer}-btn`;
                rightBtn.onclick = () => insertInRowRight(r);
                rowRightDiv.appendChild(rightBtn);
            }
        }

        // ----- AI OPPONENT CODE -----
        // AI plays as Player 2.
        function aiMakeMove() {
            setTimeout(() => {
                const move = chooseAIMove();
                if (move.type === 'drop') {
                    dropInColumn(move.index);
                } else if (move.type === 'insertLeft') {
                    insertInRowLeft(move.index);
                } else if (move.type === 'insertRight') {
                    insertInRowRight(move.index);
                }
            }, 500);
        }

        // Returns legal moves given a board (used in simulations).
        function getLegalMoves(simBoard) {
            let moves = [];
            for (let c = 0; c < cols; c++) {
                if (simBoard[0][c] === null) {
                    moves.push({
                        type: 'drop',
                        index: c
                    });
                }
            }
            for (let r = 0; r < rows; r++) {
                moves.push({
                    type: 'insertLeft',
                    index: r
                });
                moves.push({
                    type: 'insertRight',
                    index: r
                });
            }
            return moves;
        }

        // Choose an AI move based on the selected difficulty.
        function chooseAIMove() {
            let legalMoves = getLegalMoves(board);

            // If there is an immediate winning move for AI, take it.
            for (let move of legalMoves) {
                if (simulateAndCheckWin(move, 2)) {
                    return move;
                }
            }

            if (aiDifficulty === 1) {
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 2 || aiDifficulty === 3) {
                // Levels 2 & 3: Attempt to block opponent’s immediate wins.
                let oppLegalMoves = [];
                for (let c = 0; c < cols; c++) {
                    if (board[0][c] === null) {
                        oppLegalMoves.push({
                            type: 'drop',
                            index: c
                        });
                    }
                }
                if (aiDifficulty >= 3) {
                    for (let r = 0; r < rows; r++) {
                        oppLegalMoves.push({
                            type: 'insertLeft',
                            index: r
                        });
                        oppLegalMoves.push({
                            type: 'insertRight',
                            index: r
                        });
                    }
                }
                let opponentWinningMoves = [];
                for (let oppMove of oppLegalMoves) {
                    if (simulateAndCheckWin(oppMove, 1)) {
                        opponentWinningMoves.push(oppMove);
                    }
                }
                let candidateMoves = [];
                for (let candidate of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, candidate, 2);
                    let blocks = true;
                    for (let oppMove of opponentWinningMoves) {
                        let sim2 = cloneBoard(sim);
                        simulateMoveOnBoard(sim2, oppMove, 1);
                        if (checkForWinForPlayerOnBoard(sim2, 1)) {
                            blocks = false;
                            break;
                        }
                    }
                    if (blocks) {
                        candidateMoves.push(candidate);
                    }
                }
                if (candidateMoves.length > 0) {
                    return candidateMoves[Math.floor(Math.random() * candidateMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            } else if (aiDifficulty === 4 || aiDifficulty === 5) {
                // Use minimax search. Level 4: Depth 2; Level 5: Depth 3.
                let depth = (aiDifficulty === 4 ? 2 : 3);
                let bestScore = -Infinity;
                let bestMoves = [];
                for (let move of legalMoves) {
                    let sim = cloneBoard(board);
                    simulateMoveOnBoard(sim, move, 2);
                    let score = minimax(sim, depth, false);
                    if (score > bestScore) {
                        bestScore = score;
                        bestMoves = [move];
                    } else if (score === bestScore) {
                        bestMoves.push(move);
                    }
                }
                if (bestMoves.length > 0) {
                    return bestMoves[Math.floor(Math.random() * bestMoves.length)];
                }
                return legalMoves[Math.floor(Math.random() * legalMoves.length)];
            }
        }

        // ----- AI SIMULATION HELPERS -----
        function cloneBoard(board) {
            return board.map(row => row.slice());
        }

        function applyGravitySim(simBoard) {
            for (let c = 0; c < cols; c++) {
                let stack = [];
                for (let r = 0; r < rows; r++) {
                    if (simBoard[r][c]) stack.push(simBoard[r][c]);
                }
                for (let r = rows - 1; r >= 0; r--) {
                    simBoard[r][c] = stack.length ? stack.pop() : null;
                }
            }
        }

        function simulateMoveOnBoard(simBoard, move, player) {
            if (move.type === 'drop') {
                for (let r = rows - 1; r >= 0; r--) {
                    if (!simBoard[r][move.index]) {
                        simBoard[r][move.index] = player;
                        break;
                    }
                }
            } else if (move.type === 'insertLeft') {
                let r = move.index;
                if (simBoard[r][0] === null) {
                    simBoard[r][0] = player;
                } else {
                    let end = 0;
                    while (end < cols && simBoard[r][end] !== null) {
                        end++;
                    }
                    if (end < cols) {
                        for (let i = end; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    } else {
                        for (let i = cols - 1; i > 0; i--) {
                            simBoard[r][i] = simBoard[r][i - 1];
                        }
                    }
                    simBoard[r][0] = player;
                }
            } else if (move.type === 'insertRight') {
                let r = move.index;
                if (simBoard[r][cols - 1] === null) {
                    simBoard[r][cols - 1] = player;
                } else {
                    let start = cols - 1;
                    while (start >= 0 && simBoard[r][start] !== null) {
                        start--;
                    }
                    if (start >= 0) {
                        for (let i = start + 1; i < cols; i++) {
                            simBoard[r][i - 1] = simBoard[r][i];
                        }
                    } else {
                        for (let i = 0; i < cols - 1; i++) {
                            simBoard[r][i] = simBoard[r][i + 1];
                        }
                    }
                    simBoard[r][cols - 1] = player;
                }
            }
            applyGravitySim(simBoard);
        }

        function checkForWinForPlayerOnBoard(simBoard, player) {
            for (let r = 0; r < rows; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r][c + 1] === player &&
                        simBoard[r][c + 2] === player &&
                        simBoard[r][c + 3] === player
                    ) {
                        return true;
                    }
                }
            }
            for (let c = 0; c < cols; c++) {
                for (let r = 0; r <= rows - 4; r++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c] === player &&
                        simBoard[r + 2][c] === player &&
                        simBoard[r + 3][c] === player
                    ) {
                        return true;
                    }
                }
            }
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 0; c <= cols - 4; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c + 1] === player &&
                        simBoard[r + 2][c + 2] === player &&
                        simBoard[r + 3][c + 3] === player
                    ) {
                        return true;
                    }
                }
            }
            for (let r = 0; r <= rows - 4; r++) {
                for (let c = 3; c < cols; c++) {
                    if (
                        simBoard[r][c] === player &&
                        simBoard[r + 1][c - 1] === player &&
                        simBoard[r + 2][c - 2] === player &&
                        simBoard[r + 3][c - 3] === player
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }

        function simulateAndCheckWin(move, player) {
            const simBoard = cloneBoard(board);
            simulateMoveOnBoard(simBoard, move, player);
            return checkForWinForPlayerOnBoard(simBoard, player);
        }

        function minimax(simBoard, depth, isMaximizing) {
            if (checkForWinForPlayerOnBoard(simBoard, 2)) {
                return 1000;
            }
            if (checkForWinForPlayerOnBoard(simBoard, 1)) {
                return -1000;
            }
            if (depth === 0) {
                return 0;
            }
            let legal = getLegalMoves(simBoard);
            if (isMaximizing) {
                let maxEval = -Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, 2);
                    let eval = minimax(boardCopy, depth - 1, false);
                    maxEval = Math.max(maxEval, eval);
                }
                return maxEval;
            } else {
                let minEval = Infinity;
                for (let move of legal) {
                    let boardCopy = cloneBoard(simBoard);
                    simulateMoveOnBoard(boardCopy, move, 1);
                    let eval = minimax(boardCopy, depth - 1, true);
                    minEval = Math.min(minEval, eval);
                }
                return minEval;
            }
        }

        // Start a new game automatically when the page loads.
        startNewGame();
    </script>
</body>

</html>